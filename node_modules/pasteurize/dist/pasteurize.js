"use strict";
var Crypto = require("crypto");
;
var Pasteurize = (function () {
    function Pasteurize(keyLength, saltLength, iterations, digest) {
        this.keyLength = keyLength;
        this.saltLength = saltLength;
        this.iterations = iterations;
        this.digest = digest;
        if (keyLength === null || keyLength < 0) {
            throw new TypeError('Key Length must be a non-negative number');
        }
        if (saltLength === null || saltLength < 0) {
            throw new TypeError('Salt Length must be a non-negative number');
        }
        if (iterations === null || iterations < 0) {
            throw new TypeError('Iterations must be a non-negative number');
        }
        if (Crypto.getHashes().indexOf(digest) < 0) {
            throw new TypeError('Unsupported digest type');
        }
    }
    Pasteurize.prototype.hashPassword = function (password, cb) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            Crypto.randomBytes(_this.saltLength, function (err, salt) {
                if (err) {
                    return reject(err);
                }
                return Crypto.pbkdf2(password, salt, _this.iterations, _this.keyLength, _this.digest, function (err, key) {
                    if (err) {
                        return reject(err);
                    }
                    return resolve(makeHashString(_this.digest, _this.iterations, salt, key));
                });
            });
        });
        if (cb) {
            promise.then(function (hash) {
                cb(null, hash);
            })
                .catch(function (e) {
                cb(e);
            });
            return;
        }
        return promise;
    };
    Pasteurize.prototype.hashPasswordSync = function (password) {
        var salt = Crypto.randomBytes(this.saltLength);
        var hash = Crypto.pbkdf2Sync(password, salt, this.iterations, this.keyLength, this.digest);
        return makeHashString(this.digest, this.iterations, salt, hash);
    };
    Pasteurize.prototype.verifyPassword = function (password, hashedPassword, cb) {
        var promise = new Promise(function (resolve, reject) {
            var hashComponents = extractHashComponents(hashedPassword);
            if (!hashComponents) {
                return resolve(false);
            }
            var digest = hashComponents.digest, iterations = hashComponents.iterations, salt = hashComponents.salt, checksum = hashComponents.checksum, checksum_b64 = hashComponents.checksum_b64;
            Crypto.pbkdf2(password, salt, iterations, checksum_b64.length, digest, function (err, checkHash) {
                if (err) {
                    return reject(err);
                }
                return resolve(ab64encode(checkHash) === checksum);
            });
        });
        if (cb) {
            promise.then(function (matches) {
                cb(null, matches);
            })
                .catch(function (e) {
                cb(e);
            });
            return;
        }
        return promise;
    };
    Pasteurize.prototype.verifyPasswordSync = function (password, hashedPassword) {
        var hashComponents = extractHashComponents(hashedPassword);
        if (!hashComponents) {
            return false;
        }
        var digest = hashComponents.digest, iterations = hashComponents.iterations, salt = hashComponents.salt, checksum = hashComponents.checksum, checksum_b64 = hashComponents.checksum_b64;
        var checkHash = Crypto.pbkdf2Sync(password, salt, iterations, checksum_b64.length, digest);
        return ab64encode(checkHash) === checksum;
    };
    return Pasteurize;
}());
exports.Pasteurize = Pasteurize;
function ab64encode(buffer) {
    return buffer.toString('base64').replace(/\+/g, '.').replace(/\=+$/, '');
}
function ab64decode(data) {
    var offset = data.length & 3;
    if (offset === 1) {
        throw new Error('invalid base64 input');
    }
    var padding = '';
    switch (offset) {
        case 2:
            padding = '==';
            break;
        case 3:
            padding = '=';
            break;
    }
    return new Buffer(data.replace(/\./g, '+') + padding, 'base64');
}
function makeHashString(digest, iterations, salt, encoded) {
    return [
        "$pbkdf2-" + digest,
        iterations,
        ab64encode(salt),
        ab64encode(encoded)
    ].join('$');
}
function parseHashString(hash) {
    return hash.match(/^\$pbkdf2-(\w+)\$(\d+)\$([A-Za-z0-9\.\/]+)\$([A-Za-z0-9\.\/]+$)/);
}
function extractHashComponents(hash) {
    var match = parseHashString(hash);
    if (!match || !match.length) {
        return null;
    }
    var digest = match[1];
    if (Crypto.getHashes().indexOf(digest) < 0) {
        throw new TypeError('Unsupported digest');
    }
    var iterations = parseInt(match[2], 10), salt = ab64decode(match[3]), checksum = match[4], checksum_b64 = ab64decode(checksum);
    return {
        digest: digest,
        iterations: iterations,
        salt: salt,
        checksum: checksum,
        checksum_b64: checksum_b64
    };
}
